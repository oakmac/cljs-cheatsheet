{"cljs.core/*":{"full-name":"cljs.core/*","signature":["[]","[x]","[x y]","[x y & more]"],"description-html":"<p>Returns the product of nums.</p>\n<p><code>(*)</code> returns 1.</p>\n","related":["cljs.core/+","cljs.core//"]},"cljs.core/+":{"full-name":"cljs.core/+","signature":["[]","[x]","[x y]","[x y & more]"],"description-html":"<p>Returns the sum of nums.</p>\n<p><code>(+)</code> returns 0.</p>\n","related":["cljs.core/*","cljs.core/-"]},"cljs.core/-":{"full-name":"cljs.core/-","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>If no <code>y</code>s are supplied, returns the negation of <code>x</code>, else subtracts the <code>y</code>s\nfrom <code>x</code> and returns the result.</p>\n","related":["cljs.core/+"]},"cljs.core/->":{"full-name":"cljs.core/->","signature":["[x & forms]"],"description-html":"<p>The thread-first macro &quot;threads&quot; an expression through several forms as the\nsecond item in a list.</p>\n<p>Inserts <code>x</code> as the second item in the first form, making a list of it if it is\nnot a list already. If there are more forms, inserts the first form as the\nsecond item in second form, etc.</p>\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(-&gt; x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x (d (a x b c)) y z)</pre></td></tr></tbody></table>","related":["cljs.core/->>"],"type":"macro"},"cljs.core/->>":{"full-name":"cljs.core/->>","signature":["[x & forms]"],"description-html":"<p>The thread-last macro &quot;threads&quot; an expression through several forms as the last\nitem in a list.</p>\n<p>Inserts <code>x</code> as the last item in the first form, making a list of it if it is not\na list already. If there are more forms, inserts the first form as the last item\nin second form, etc.</p>\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(-&gt;&gt; x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x y z (d (a b c x)))</pre></td></tr></tbody></table>","related":["cljs.core/->"],"type":"macro"},"cljs.core//":{"full-name":"cljs.core//","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>If no denominators are supplied, returns 1/numerator, else returns numerator\ndivided by all of the denominators.</p>\n","related":["cljs.core/*","cljs.core/quot"]},"cljs.core/<":{"full-name":"cljs.core/<","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns true if each successive number argument is greater than the previous\none, false otherwise.</p>\n","related":["cljs.core/<="]},"cljs.core/<=":{"full-name":"cljs.core/<=","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns true if each successive number argument is greater than or equal to the\nprevious one, false otherwise.</p>\n","related":["cljs.core/<"]},"cljs.core/=":{"full-name":"cljs.core/=","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns true if the value of <code>x</code> equals the value of <code>y</code>, false otherwise.</p>\n<p><code>=</code> is a value comparison, not an identity comparison.</p>\n<p>All collections can be tested for value, regardless of &quot;depth&quot;.</p>\n","related":["cljs.core/==","cljs.core/not=","cljs.core/identical?"]},"cljs.core/==":{"full-name":"cljs.core/==","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>This is an equality check for numbers of different types that was carried over from Clojure,\nto allow compatibility when converting code to ClojureScript.</p>\n<p>Since there is only a single number type in JavaScript, 64-bit floating point, there is no\nreason to use the <code>==</code> operator in ClojureScript.</p>\n<p>Behavior on non-number arguments is undefined.</p>\n","related":["cljs.core/=","cljs.core/identical?"]},"cljs.core/>":{"full-name":"cljs.core/>","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns true if each successive number argument is less than the previous\none, false otherwise.</p>\n","related":["cljs.core/>="]},"cljs.core/>=":{"full-name":"cljs.core/>=","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns true if each successive number argument is less than or equal to the\nprevious one, false otherwise.</p>\n","related":["cljs.core/>"]},"cljs.core/aclone":{"full-name":"cljs.core/aclone","signature":["[arr]"],"description-html":"<p>Creates a clone of the given JavaScript array <code>arr</code>.  The result is a new\nJavaScript array, which is a shallow copy, not a deep copy.</p>\n","related":["cljs.core/array","cljs.core/make-array"]},"cljs.core/add-watch":{"full-name":"cljs.core/add-watch","signature":["[a key f]"],"description-html":"<p>Adds a watch function <code>f</code> to atom <code>a</code> that will execute when the value of <code>a</code>\nchanges.</p>\n<p>The watch function takes 4 arguments: a key, the atom, its old state, and its\nnew state.</p>\n<p><code>key</code> should be a keyword and can be used with <code>remove-watch</code> to remove the\nwatch function.</p>\n","related":["cljs.core/remove-watch"]},"cljs.core/aget":{"full-name":"cljs.core/aget","signature":["[array i]","[array i & idxs]"],"description-html":"<p>Returns the value at index <code>i</code> from JavaScript arrays and objects.</p>\n<p>Can be used to retrieve nested properties with the additional <code>idxs</code> arguments.</p>\n","related":["cljs.core/..","cljs.core/aset","cljs.core/get","cljs.core/nth"]},"cljs.core/and":{"full-name":"cljs.core/and","signature":["[]","[x]","[x & next]"],"description-html":"<p>Evaluates arguments one at a time from left to right. If an argument returns\nlogical false (nil or false), <code>and</code> returns that value and doesn&#39;t evaluate any\nof the other arguments, otherwise it returns the value of the last argument.</p>\n<p><code>(and)</code> returns true.</p>\n","related":["cljs.core/or","cljs.core/if"],"type":"macro"},"cljs.core/apply":{"full-name":"cljs.core/apply","signature":["[f args]","[f x args]","[f x y args]","[f x y z args]","[f a b c d & args]"],"description-html":"<p>Applies function <code>f</code> to the argument list formed by prepending intervening\narguments to <code>args</code>.</p>\n","related":["cljs.core/map"]},"cljs.core/array":{"full-name":"cljs.core/array","signature":["[& args]"],"description-html":"<p>Creates a JavaScript array containing <code>args</code>.</p>\n<p>The tagged literal <code>#js [1 2 3]</code> is equivalent to <code>(array 1 2 3)</code></p>\n","related":["cljs.core/aclone","cljs.core/make-array","cljs.core/clj->js"]},"cljs.core/array-map":{"full-name":"cljs.core/array-map","signature":["[& keyvals]"],"description-html":"<p>Returns a new array map (a map implemented with arrays) with the supplied mappings.</p>\n<p><code>keyvals</code> must be an even number of forms.</p>\n","related":["cljs.core/assoc","cljs.core/hash-map","cljs.core/sorted-map"]},"cljs.core/array?":{"full-name":"cljs.core/array?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a JavaScript array, false otherwise.</p>\n","related":["cljs.core/object?"]},"cljs.core/as->":{"full-name":"cljs.core/as->","signature":["[expr name & forms]"],"description-html":"<p>Binds <code>name</code> to <code>expr</code>, evaluates the first form in the lexical context of that\nbinding, then binds <code>name</code> to that result, repeating for each successive form,\nreturning the result of the last form.</p>\n<p>Useful for when you want a threading macro to use different &quot;places&quot; at each\nform.</p>\n","related":["cljs.core/->","cljs.core/->>","cljs.core/cond->","cljs.core/cond->>","cljs.core/some->","cljs.core/some->>"],"type":"macro"},"cljs.core/aset":{"full-name":"cljs.core/aset","signature":["[array i val]","[array idx idx2 & idxv]"],"description-html":"<p>Sets <code>val</code> at index <code>i</code> in JavaScript arrays and objects.</p>\n<p>Can be used to set nested properties with the additional <code>idxs</code> arguments.</p>\n","related":["cljs.core/aget","cljs.core/set!","cljs.core/assoc-in"]},"cljs.core/assoc":{"full-name":"cljs.core/assoc","signature":["[coll k v]","[coll k v & kvs]"],"description-html":"<p>assoc(iate)</p>\n<p>When applied to a map, returns a new map that contains the mapping of key(s) to\nval(s).</p>\n<p>Has no effect on the map type (hashed/sorted).</p>\n<p>When applied to a vector, returns a new vector that contains value <code>v</code> at index\n<code>k</code>.</p>\n","related":["cljs.core/assoc-in","cljs.core/dissoc","cljs.core/merge"]},"cljs.core/assoc-in":{"full-name":"cljs.core/assoc-in","signature":["[m [k & ks] v]"],"description-html":"<p>Associates a value in a nested associative structure, where <code>ks</code> is a sequence\nof keys and <code>v</code> is the new value. Returns a new nested structure.</p>\n<p>If any levels do not exist, hash-maps will be created.</p>\n","related":["cljs.core/assoc","cljs.core/update-in","cljs.core/dissoc-in","cljs.core/get-in"]},"cljs.core/associative?":{"full-name":"cljs.core/associative?","signature":["[coll]"],"description-html":"<p>Returns true if <code>coll</code> implements the <code>IAssociative</code> protocol, false otherwise.</p>\n<p>Maps and vectors are associative.</p>\n"},"cljs.core/atom":{"full-name":"cljs.core/atom","signature":["[x]","[x opts]"],"description-html":"<p>Creates and returns an atom with an initial value of <code>x</code>.</p>\n<p><code>opts</code> is an optional map with optional keys <code>:meta</code> and <code>:validator</code>.</p>\n<p><code>:meta</code> should be a <a href=\"http://clojure.org/metadata\">metadata-map</a> for the atom.</p>\n<p><code>:validator</code> should be a validator function for the atom. See <code>set-validator!</code>\nfor more information.</p>\n","related":["cljs.core/atom","cljs.core/swap!","cljs.core/reset!","cljs.core/set-validator!","cljs.core/get-validator"]},"cljs.core/bit-and":{"full-name":"cljs.core/bit-and","signature":["[x y]","[x y & more]"],"description-html":"<p>Bitwise &quot;and&quot;.  Same as <code>x &amp; y</code> in JavaScript.</p>\n","related":["cljs.core/bit-or"]},"cljs.core/bit-and-not":{"full-name":"cljs.core/bit-and-not","signature":["[x y]","[x y & more]"],"description-html":"<p>Bitwise &quot;and&quot; <code>x</code> with bitwise &quot;not&quot; <code>y</code>.  Same as <code>x &amp; ~y</code> in JavaScript.</p>\n","related":["cljs.core/bit-and","cljs.core/bit-not"]},"cljs.core/bit-clear":{"full-name":"cljs.core/bit-clear","signature":["[x n]"],"description-html":"<p>Clear bit at index <code>n</code>.  Same as <code>x &amp; ~(1 &lt;&lt; y)</code> in JavaScript.</p>\n","related":["cljs.core/bit-set"]},"cljs.core/bit-flip":{"full-name":"cljs.core/bit-flip","signature":["[x n]"],"description-html":"<p>Flip bit at index <code>n</code></p>\n"},"cljs.core/bit-not":{"full-name":"cljs.core/bit-not","signature":["[x]"],"description-html":"<p>Bitwise complement</p>\n"},"cljs.core/bit-or":{"full-name":"cljs.core/bit-or","signature":["[x y]"],"description-html":"<p>Bitwise or</p>\n","related":["cljs.core/bit-and","cljs.core/bit-xor"]},"cljs.core/bit-set":{"full-name":"cljs.core/bit-set","signature":["[x n]"],"description-html":"<p>Set bit at index <code>n</code></p>\n","related":["cljs.core/bit-clear"]},"cljs.core/bit-shift-left":{"full-name":"cljs.core/bit-shift-left","signature":["[x n]"],"description-html":"<p>Bitwise shift left</p>\n","related":["cljs.core/bit-shift-right"]},"cljs.core/bit-shift-right":{"full-name":"cljs.core/bit-shift-right","signature":["[x n]"],"description-html":"<p>Bitwise shift right</p>\n","related":["cljs.core/bit-shift-left","cljs.core/unsigned-bit-shift-right"]},"cljs.core/bit-test":{"full-name":"cljs.core/bit-test","signature":["[x n]"],"description-html":"<p>Test bit at index <code>n</code></p>\n"},"cljs.core/bit-xor":{"full-name":"cljs.core/bit-xor","signature":["[x y]"],"description-html":"<p>Bitwise exclusive or</p>\n","related":["cljs.core/bit-and","cljs.core/bit-or"]},"cljs.core/butlast":{"full-name":"cljs.core/butlast","signature":["[s]"],"description-html":"<p>Returns a sequence of all but the last item in <code>s</code>.</p>\n<p><code>butlast</code> runs in linear time.</p>\n","related":["cljs.core/first","cljs.core/rest","cljs.core/last","cljs.core/next","cljs.core/drop-last","cljs.core/take-last"]},"cljs.core/case":{"full-name":"cljs.core/case","signature":["[e & clauses]"],"description-html":"<p>Takes an expression and a set of clauses. Each clause can take the form of\neither:</p>\n<p><code>test-constant result-expr</code></p>\n<p><code>(test-constant1 ... test-constantN)  result-expr</code></p>\n<p>The test-constants are not evaluated. They must be compile-time literals, and\nneed not be quoted. If the expression is equal to a test-constant, the\ncorresponding <code>result-expr</code> is returned. A single default expression can follow\nthe clauses, and its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an Error is thrown.</p>\n<p>Unlike <code>cond</code> and <code>condp</code>, <code>case</code> does a constant-time dispatch, the clauses are\nnot considered sequentially. All manner of constant expressions are acceptable\nin <code>case</code>, including numbers, strings, symbols, keywords, and ClojureScript\ncomposites thereof. Note that since lists are used to group multiple constants\nthat map to the same expression, a vector can be used to match a list if needed.\nThe test-constants need not be all of the same type.</p>\n","related":["cljs.core/cond","cljs.core/condp"],"type":"macro"},"cljs.core/catch":{"full-name":"cljs.core/catch","signature":["[exception-type name expr*]"],"description-html":"<p><code>catch</code> should be used inside of a <code>try</code> expression.</p>\n<p><code>exception-type</code> should be the type of exception thrown (usually <code>js/Error</code> or\n<code>js/Object</code>). When there is a match, the thrown exception will be bound to\n<code>name</code> inside of <code>expr*</code> and <code>expr*</code> will be evaluated and returned as the value\nof the <code>try</code> expression.</p>\n","related":["cljs.core/try","cljs.core/finally","cljs.core/throw"],"type":"special form"},"cljs.core/char":{"full-name":"cljs.core/char","signature":["[x]"],"description-html":"<p>Coerce to char</p>\n"},"cljs.core/clj->js":{"full-name":"cljs.core/clj->js","signature":["[x]"],"description-html":"<p>Recursively transforms ClojureScript values to JavaScript.</p>\n<table>\n<thead>\n<tr>\n<th>ClojureScript</th>\n<th></th>\n<th>JavaScript</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set</td>\n<td><code>#{}</code></td>\n<td>Array</td>\n<td><code>[]</code></td>\n</tr>\n<tr>\n<td>Vector</td>\n<td><code>[]</code></td>\n<td>Array</td>\n<td><code>[]</code></td>\n</tr>\n<tr>\n<td>List</td>\n<td><code>()</code></td>\n<td>Array</td>\n<td><code>[]</code></td>\n</tr>\n<tr>\n<td>Keyword</td>\n<td><code>:foo</code></td>\n<td>String</td>\n<td><code>&quot;foo&quot;</code></td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td><code>bar</code></td>\n<td>String</td>\n<td><code>&quot;bar&quot;</code></td>\n</tr>\n<tr>\n<td>Map</td>\n<td><code>{}</code></td>\n<td>Object</td>\n<td><code>{}</code></td>\n</tr>\n</tbody>\n</table>\n","related":["cljs.core/js->clj"]},"cljs.core/coll?":{"full-name":"cljs.core/coll?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a collection, false otherwise.</p>\n<p>Lists, maps, sets, and vectors are collections.</p>\n","related":["cljs.core/seq?","cljs.core/list?","cljs.core/sequential?"]},"cljs.core/comp":{"full-name":"cljs.core/comp","signature":["[]","[f]","[f g]","[f g h]","[f1 f2 f3 & fs]"],"description-html":"<p>Takes a set of functions (<code>fn</code>s) and returns a function that is the composition\nof those functions.</p>\n<p>The returned function takes a variable number of arguments, applies the\nrightmost of <code>fn</code>s to the arguments, the next <code>fn</code> (right-to-left) to the\nresult, etc.</p>\n<p><code>((comp a b c) x y)</code> =&gt; <code>(a (b (c x y)))</code></p>\n","related":["cljs.core/partial","cljs.core/juxt"]},"cljs.core/compare":{"full-name":"cljs.core/compare","signature":["[x y]"],"description-html":"<p>Comparator.</p>\n<p>Returns a negative number, zero, or a positive number when <code>x</code> is logically\n&quot;less than&quot;, &quot;equal to&quot;, or &quot;greater than&quot; <code>y</code>.</p>\n<p>Uses <code>IComparable</code> if available and <code>google.array.defaultCompare</code> for objects of\nthe same type. nil is treated as a special case and is always less than any\nother object.</p>\n","related":["cljs.core/sort-by","cljs.core/sorted-set-by","cljs.core/sorted-map-by"]},"cljs.core/compare-and-set!":{"full-name":"cljs.core/compare-and-set!","signature":["[a oldval newval]"],"description-html":"<p>Atomically sets the value of atom <code>a</code> to <code>newval</code> if and only if the current\nvalue of the atom is identical to <code>oldval</code>.</p>\n<p>Returns true if set happened, false otherwise.</p>\n","related":["cljs.core/atom","cljs.core/reset!","cljs.core/swap!"]},"cljs.core/complement":{"full-name":"cljs.core/complement","signature":["[f]"],"description-html":"<p>Takes a function <code>f</code> and returns a function that takes the same arguments as\n<code>f</code>, has the same effects, if any, and returns the opposite truth value.</p>\n","related":["cljs.core/not"]},"cljs.core/concat":{"full-name":"cljs.core/concat","signature":["[]","[x]","[x y]","[x y & zs]"],"description-html":"<p>Returns a lazy sequence representing the concatenation of the elements in the\nsupplied collections.</p>\n","related":["cljs.core/conj","cljs.core/into"]},"cljs.core/cond":{"full-name":"cljs.core/cond","signature":["[& clauses]"],"description-html":"<p><code>clauses</code> must be an even number of forms, ie: <code>(cond t1 e1, t2 e2, t3 e3)</code>.\nEach test <code>t</code> is evaluated one at a time. If a test returns logical true, <code>cond</code>\nevaluates and returns the corresponding expression <code>e</code> and does not evaluate any\nof the other tests or expressions.</p>\n<p>It is idiomatic to provide a default case as the last test pair using the\nkeyword <code>:else</code> (a keyword always evaluates to logical true).</p>\n<p><code>(cond)</code> returns nil.</p>\n","related":["cljs.core/condp","cljs.core/case","cljs.core/if"],"type":"macro"},"cljs.core/cond->":{"full-name":"cljs.core/cond->","signature":["[expr & clauses]"],"description-html":"<p>Takes an expression and a set of test/form pairs. Threads <code>expr</code> (via <code>-&gt;</code>)\nthrough each form for which the corresponding test expression is true.</p>\n<p>Note that, unlike <code>cond</code> branching, <code>cond-&gt;</code> threading does not short circuit\nafter the first true test expression.</p>\n","related":["cljs.core/->","cljs.core/->>","cljs.core/cond->>","cljs.core/cond"],"type":"macro"},"cljs.core/cond->>":{"full-name":"cljs.core/cond->>","signature":["[expr & clauses]"],"description-html":"<p>Takes an expression and a set of test/form pairs. Threads <code>expr</code> (via <code>-&gt;&gt;</code>)\nthrough each form for which the corresponding test expression is true.</p>\n<p>Note that, unlike <code>cond</code> branching, <code>cond-&gt;&gt;</code> threading does not short circuit\nafter the first true test expression.</p>\n","related":["cljs.core/->","cljs.core/->>","cljs.core/cond->","cljs.core/cond"],"type":"macro"},"cljs.core/condp":{"full-name":"cljs.core/condp","signature":["[pred expr & clauses]"],"description-html":"<p>Takes a binary predicate, an expression, and a set of clauses. There are two\nkinds of clauses:</p>\n<p>Binary clause: <code>test-expr</code> <code>result-expr</code></p>\n<p>Ternary clause: <code>test-expr</code> <code>:&gt;&gt;</code> <code>result-fn</code><br />\n(Note: <code>:&gt;&gt;</code> is an ordinary keyword)</p>\n<p>For each clause, <code>(pred test-expr expr)</code> is evaluated. If it returns logical\ntrue, the clause is a match.</p>\n<p>If a binary clause matches, its <code>result-expr</code> is returned.</p>\n<p>If a ternary clause matches, its <code>result-fn</code> is called with the result of the\npredicate and returned by <code>condp</code>. <code>result-fn</code> should take one argument.</p>\n<p>A single default expression can follow the clauses, and its value will be\nreturned if no clause matches.</p>\n<p>If no default expression is provided and no clause matches, an Error is thrown.</p>\n","related":["cljs.core/cond","cljs.core/if"],"type":"macro"},"cljs.core/conj":{"full-name":"cljs.core/conj","signature":["[]","[coll]","[coll x]","[coll x & xs]"],"description-html":"<p>conj(oin)</p>\n<p>Returns a new collection with the <code>x</code>s &quot;added&quot; to <code>coll</code>.</p>\n<p><code>conj</code> adds items to the end of a vector, the beginning of a list, and into a\nset.</p>\n<p><code>conj</code> works with maps by merging and also supports vector pairs with two\nelements.</p>\n<p>Multiple <code>x</code>s are added in order, as if called one at a time.</p>\n<p><code>(conj nil item)</code> returns <code>(item)</code>.</p>\n","related":["cljs.core/cons","cljs.core/into","cljs.core/merge","cljs.core/peek","cljs.core/pop"]},"cljs.core/cons":{"full-name":"cljs.core/cons","signature":["[x coll]"],"description-html":"<p>Returns a new sequence where <code>x</code> is the first element and <code>coll</code> is the rest.</p>\n","related":["cljs.core/conj"]},"cljs.core/constantly":{"full-name":"cljs.core/constantly","signature":["[x]"],"description-html":"<p>Returns a function that takes any number of arguments and always returns <code>x</code>.</p>\n","related":["cljs.core/repeatedly"]},"cljs.core/contains?":{"full-name":"cljs.core/contains?","signature":["[coll k]"],"description-html":"<p>Returns true if <code>k</code> is present in <code>coll</code>, otherwise returns false.</p>\n<p>Note that for numerically indexed collections like vectors and arrays, this\ntests if the numeric key is within the range of indexes.</p>\n<p><code>contains?</code> operates in constant or logarithmic time; it will not perform a\nlinear search for a value.</p>\n","related":["cljs.core/some","cljs.core/get"]},"cljs.core/count":{"full-name":"cljs.core/count","signature":["[x]"],"description-html":"<p>Returns the number of items in <code>x</code>.</p>\n<p><code>count</code> works on arrays, lists, maps, sets, strings, and vectors.</p>\n<p><code>(count nil)</code> returns 0.</p>\n"},"cljs.core/counted?":{"full-name":"cljs.core/counted?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> executes <code>count</code> in constant time, false otherwise.</p>\n<p>Lists, maps, sets, strings, and vectors can be counted in constant time.</p>\n"},"cljs.core/cycle":{"full-name":"cljs.core/cycle","signature":["[coll]"],"description-html":"<p>Returns an infinite lazy sequence of repetitions of the items in <code>coll</code>.</p>\n","related":["cljs.core/lazy-seq","cljs.core/repeatedly"]},"cljs.core/dec":{"full-name":"cljs.core/dec","signature":["[x]"],"description-html":"<p>Returns a number one less than <code>x</code>.</p>\n","related":["cljs.core/inc"]},"cljs.core/declare":{"full-name":"cljs.core/declare","signature":["[& names]"],"description-html":"<p>Uses <code>def</code> to establish symbols of <code>names</code> with no bindings.</p>\n<p>Useful for making forward declarations.</p>\n","related":["cljs.core/def"],"type":"macro"},"cljs.core/def":{"full-name":"cljs.core/def","signature":["[symbol]","[symbol init]","[symbol doc-string init]"],"description-html":"<p>Creates a global variable with the name of <code>symbol</code> and a namespace of the\ncurrent namespace.</p>\n<p>If <code>init</code> is supplied, it is evaluated and the result is assigned to <code>symbol</code>.</p>\n<p><code>doc-string</code> is an optional documentation string.</p>\n<p><code>def</code> is one of ClojureScript&#39;s <a href=\"http://clojure.org/special_forms\">special forms</a>\nand is used by many macros to define common elements (ie: <code>defn</code>, <code>defmacro</code>,\netc).</p>\n","related":["cljs.core/defn","cljs.core/fn","cljs.core/defmacro","cljs.core/defmulti"],"type":"special form"},"cljs.core/defn":{"full-name":"cljs.core/defn","signature":["[name doc-string? attr-map? [params*] prepost-map? body]","[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"],"description-html":"<p>Defines a function.</p>\n<p><code>doc-string?</code> is an optional documentation string.</p>\n<p><code>attr-map?</code> is an optional map of <a href=\"http://clojure.org/metadata\">metadata</a> to\nattach to the global variable name.</p>\n<p><code>prepost-map?</code> is an optional map with optional keys <code>:pre</code> and <code>:post</code> that\ncontain collections of <a href=\"http://blog.fogus.me/2009/12/21/clojures-pre-and-post/\">pre or post conditions</a>\nfor the function.</p>\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(defn foo [a b c]\n  (* a b c))</pre></td>\n      <td><pre>\n(def foo\n  (fn [a b c]\n    (* a b c)))</pre></td></tr></tbody></table>","related":["cljs.core/def","cljs.core/defn-","cljs.core/defmacro","cljs.core/fn"],"type":"macro"},"cljs.core/defn-":{"full-name":"cljs.core/defn-","signature":["[name & decls]"],"description-html":"<p>Same as <code>defn</code>, but adds <code>{:private true}</code> metadata to the definition.</p>\n<p>Note: <code>:private</code> metadata is not currently enforced by the ClojureScript\ncompiler.</p>\n","related":["cljs.core/defn"],"type":"macro"},"cljs.core/deref":{"full-name":"cljs.core/deref","signature":["[x]"],"description-html":"<p>Returns the current value of atom <code>x</code>.</p>\n<p>The <code>@</code> reader macro is often used instead of <code>deref</code>. <code>@foo</code> is the same thing\nas <code>(deref foo)</code>.</p>\n","related":["cljs.core/atom"]},"cljs.core/disj":{"full-name":"cljs.core/disj","signature":["[coll]","[coll k]","[coll k & ks]"],"description-html":"<p>disj(oin). Returns a new set of the same (hashed/sorted) type, that does not\ncontain key(s).</p>\n","related":["cljs.core/dissoc","cljs.core/disj!","clojure.set/difference"]},"cljs.core/dissoc":{"full-name":"cljs.core/dissoc","signature":["[coll]","[coll k]","[coll k & ks]"],"description-html":"<p>dissoc(iate)</p>\n<p>Returns a new map that does not contain a mapping for key(s).</p>\n<p>Has no effect on the map type (hashed/sorted).</p>\n","related":["cljs.core/assoc","cljs.core/dissoc-in","cljs.core/disj","cljs.core/select-keys"]},"cljs.core/distinct":{"full-name":"cljs.core/distinct","signature":["[coll]"],"description-html":"<p>Returns a lazy sequence of the elements of <code>coll</code> with duplicates removed.</p>\n","related":["cljs.core/distinct?"]},"cljs.core/distinct?":{"full-name":"cljs.core/distinct?","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns true if no two of the arguments are <code>=</code></p>\n","related":["cljs.core/distinct"]},"cljs.core/doall":{"full-name":"cljs.core/doall","signature":["[coll]","[n coll]"],"description-html":"<p>Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.</p>\n<p><code>doall</code> walks through the successive <code>next</code>s of the sequence, returning the head\nand causing the entire sequence to reside in memory at one time.</p>\n","related":["cljs.core/dorun","cljs.core/doseq"]},"cljs.core/dorun":{"full-name":"cljs.core/dorun","signature":["[coll]","[n coll]"],"description-html":"<p>Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.</p>\n<p><code>dorun</code> walks through the successive <code>next</code>s of the sequence and returns nil.</p>\n","related":["cljs.core/doall"]},"cljs.core/doseq":{"full-name":"cljs.core/doseq","signature":["[seq-exprs & body]"],"description-html":"<p>Repeatedly executes <code>body</code> (presumably for side-effects) with bindings and\nfiltering as provided by <code>for</code>. Does not retain the head of the sequence.</p>\n<p>Returns nil.</p>\n","related":["cljs.core/doall","cljs.core/dorun","cljs.core/for","cljs.core/dotimes"],"type":"macro"},"cljs.core/dotimes":{"full-name":"cljs.core/dotimes","signature":["[[name n] & body]"],"description-html":"<p>Repeatedly executes <code>body</code> (presumably for side-effects) with <code>name</code> bound to\nintegers from <code>0</code> through <code>n-1</code>.</p>\n","related":["cljs.core/repeat","cljs.core/for","cljs.core/doseq"],"type":"macro"},"cljs.core/drop":{"full-name":"cljs.core/drop","signature":["[n]","[n coll]"],"description-html":"<p>Returns a lazy sequence of all but the first <code>n</code> items in <code>coll</code>.</p>\n<p>Returns a stateful transducer when no collection is provided.</p>\n","related":["cljs.core/take","cljs.core/drop-last","cljs.core/drop-while","cljs.core/nthnext","cljs.core/nthrest"]},"cljs.core/drop-last":{"full-name":"cljs.core/drop-last","signature":["[s]","[n s]"],"description-html":"<p>Return a lazy sequence of all but the last <code>n</code> items in <code>s</code>.</p>\n<p><code>n</code> defaults to 1.</p>\n","related":["cljs.core/drop","cljs.core/drop-while"]},"cljs.core/drop-while":{"full-name":"cljs.core/drop-while","signature":["[pred]","[pred coll]"],"description-html":"<p>Returns a lazy sequence of the items in <code>coll</code> starting from the first item for\nwhich <code>(pred item)</code> returns logical false.</p>\n<p>Returns a stateful transducer when no collection is provided.</p>\n","related":["cljs.core/take-while","cljs.core/split-with"]},"cljs.core/empty":{"full-name":"cljs.core/empty","signature":["[coll]"],"description-html":"<p>Returns an empty collection of the same category as <code>coll</code>.</p>\n<p>Returns nil if <code>coll</code> is nil.</p>\n","related":["cljs.core/not-empty"]},"cljs.core/empty?":{"full-name":"cljs.core/empty?","signature":["[coll]"],"description-html":"<p>Returns true if <code>coll</code> has no items - same as <code>(not (seq coll))</code>.</p>\n<p>Please use the idiom <code>(seq x)</code> rather than <code>(not (empty? x))</code>.</p>\n","related":["cljs.core/seq"]},"cljs.core/even?":{"full-name":"cljs.core/even?","signature":["[n]"],"description-html":"<p>Returns true if <code>n</code> is an even number.</p>\n<p>Throws an exception if <code>n</code> is not an integer.</p>\n","related":["cljs.core/odd?"]},"cljs.core/every-pred":{"full-name":"cljs.core/every-pred","signature":["[p]","[p1 p2]","[p1 p2 p3]","[p1 p2 p3 & ps]"],"description-html":"<p>Takes a set of predicate functions and returns a function <code>f</code> that returns true\nif all of its composing predicates return a logical true value against all of\nits arguments, else it returns false.</p>\n<p>Note that <code>f</code> is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates.</p>\n","related":["cljs.core/some-fn","cljs.core/and"]},"cljs.core/every?":{"full-name":"cljs.core/every?","signature":["[pred coll]"],"description-html":"<p>Returns true if <code>(pred x)</code> is logical true for every <code>x</code> in <code>coll</code>, else false.</p>\n","related":["cljs.core/some","cljs.core/not-any?"]},"cljs.core/false?":{"full-name":"cljs.core/false?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is the value false, false otherwise.</p>\n","related":["cljs.core/true?","cljs.core/not"]},"cljs.core/ffirst":{"full-name":"cljs.core/ffirst","signature":["[coll]"],"description-html":"<p>Same as <code>(first (first coll))</code>.</p>\n","related":["cljs.core/first","cljs.core/fnext","cljs.core/nfirst"]},"cljs.core/filter":{"full-name":"cljs.core/filter","signature":["[f]","[f coll]"],"description-html":"<p>Returns a lazy sequence of the non-nil results of <code>(f item)</code>. Note, this means\nfalse return values will be included.</p>\n<p><code>f</code> must be free of side-effects.</p>\n<p>Returns a transducer when no collection is provided.</p>\n","related":["cljs.core/remove","cljs.core/keep"]},"cljs.core/filterv":{"full-name":"cljs.core/filterv","signature":["[pred coll]"],"description-html":"<p>Returns a vector of the items in <code>coll</code> for which <code>(pred item)</code> returns true.</p>\n<p><code>pred</code> must be free of side-effects.</p>\n"},"cljs.core/finally":{"full-name":"cljs.core/finally","signature":["[expr*]"],"description-html":"<p><code>finally</code> should be the last form inside of a <code>try</code> expression. It is optional.</p>\n<p><code>finally</code> clauses are always evaluated for their side effects whether there was\nan error or not, but they are never the return value of a <code>try</code> expression.</p>\n","related":["cljs.core/try","cljs.core/catch","cljs.core/throw"],"type":"special form"},"cljs.core/find":{"full-name":"cljs.core/find","signature":["[coll k]"],"description-html":"<p>Returns the map entry for key <code>k</code>, or nil if <code>k</code> is not found.</p>\n","related":["cljs.core/get","cljs.core/get-in"]},"cljs.core/first":{"full-name":"cljs.core/first","signature":["[coll]"],"description-html":"<p>Returns the first item in <code>coll</code> and calls <code>seq</code> on its argument.</p>\n<p>Returns nil when <code>coll</code> is nil.</p>\n","related":["cljs.core/rest","cljs.core/next","cljs.core/nth","cljs.core/second","cljs.core/take","cljs.core/ffirst"]},"cljs.core/flatten":{"full-name":"cljs.core/flatten","signature":["[x]"],"description-html":"<p>Takes any nested combination of sequential things (lists, vectors, etc.) and\nreturns their contents as a single, flat sequence.</p>\n<p><code>(flatten nil)</code> returns nil.</p>\n"},"cljs.core/fn":{"full-name":"cljs.core/fn","signature":["[name? [params*] prepost-map? body]","[name? ([params*] prepost-map? body)+]"],"description-html":"<p>Defines a function.</p>\n<p><code>name?</code> is an optional name of the function to be used inside <code>body</code>. This is\nuseful for recursive calls. Note that <code>name?</code> in <code>fn</code> is not the same as the\n<code>name</code> argument to <code>defn</code>, which defines a global symbol for the function.</p>\n<p><code>params*</code> are the arguments to the function and a binding form for the symbols\nthat the arguments will take inside the body of the function. Functions can have\narity of 0-20 and there is no runtime enforcement of arity when calling a\nfunction (just like in JavaScript).</p>\n<p><code>prepost-map?</code> is an optional map with optional keys <code>:pre</code> and <code>:post</code> that\ncontain collections of <a href=\"http://blog.fogus.me/2009/12/21/clojures-pre-and-post/\">pre or post conditions</a>\nfor the function.</p>\n<p><code>body</code> is a series of expressions that execute when the function is called. The\narguments to the function are mapped to symbols in <code>params*</code> and are available\nin <code>body</code>. The value of the last expression in <code>body</code> is the return value of\ncalling the function.</p>\n","related":["cljs.core/defn","cljs.core/defn-"],"type":"special form"},"cljs.core/fn?":{"full-name":"cljs.core/fn?","signature":["[f]"],"description-html":"<p>Returns true if <code>f</code> is a function, false otherwise.</p>\n","related":["cljs.core/ifn?"]},"cljs.core/fnext":{"full-name":"cljs.core/fnext","signature":["[coll]"],"description-html":"<p>Same as <code>(first (next coll))</code></p>\n","related":["cljs.core/ffirst","cljs.core/second"]},"cljs.core/fnil":{"full-name":"cljs.core/fnil","signature":["[f x]","[f x y]","[f x y z]"],"description-html":"<p>Takes a function <code>f</code>, and returns a function that calls <code>f</code>, replacing a nil\nfirst argument to <code>f</code> with the supplied value <code>x</code>. Higher arity versions can\nreplace arguments in the second and third positions (<code>y</code>, <code>z</code>).</p>\n<p>Note that the function <code>f</code> can take any number of arguments, not just the one(s)\nbeing nil-patched.</p>\n"},"cljs.core/for":{"full-name":"cljs.core/for","signature":["[seq-exprs body-expr]"],"description-html":"<p>List comprehension.</p>\n<p>Takes a vector of one or more binding-form/collection-expr pairs, each followed\nby zero or more modifiers, and yields a lazy sequence of evaluations of expr.</p>\n<p>Collections are iterated in a nested fashion, rightmost fastest, and nested\ncoll-exprs can refer to bindings created in prior binding-forms. Supported\nmodifiers are: <code>:let [binding-form expr ...]</code>, <code>:while test</code>, <code>:when test</code>.</p>\n","related":["cljs.core/doseq","cljs.core/doall","cljs.core/recur"],"type":"macro"},"cljs.core/frequencies":{"full-name":"cljs.core/frequencies","signature":["[coll]"],"description-html":"<p>Returns a map from distinct items in <code>coll</code> to the number of times they appear.</p>\n<p><code>(frequencies [:a :a :b])</code> =&gt; <code>{:a 2, :b 1}</code></p>\n","related":["cljs.core/group-by","cljs.core/distinct"]},"cljs.core/get":{"full-name":"cljs.core/get","signature":["[o k]","[o k not-found]"],"description-html":"<p>Returns the value mapped to key <code>k</code>.</p>\n<p>Returns <code>not-found</code> or nil if <code>k</code> is not present in <code>o</code>.</p>\n","related":["cljs.core/get-in"]},"cljs.core/get-in":{"full-name":"cljs.core/get-in","signature":["[m ks]","[m ks not-found]"],"description-html":"<p>Returns the value in a nested associative structure, where <code>ks</code> is a sequence of\nkeys.</p>\n<p>Returns nil if the key is not found, or <code>not-found</code> if supplied.</p>\n","related":["cljs.core/assoc-in","cljs.core/update-in","cljs.core/find","cljs.core/get"]},"cljs.core/get-validator":{"full-name":"cljs.core/get-validator","signature":["[a]"],"description-html":"<p>Returns the validator function for atom <code>a</code>.</p>\n","related":["cljs.core/atom","cljs.core/set-validator!"]},"cljs.core/group-by":{"full-name":"cljs.core/group-by","signature":["[f coll]"],"description-html":"<p>Returns a map of the elements of <code>coll</code> keyed by the result of running <code>f</code> on\neach element.</p>\n<p>The value at each key will be a vector of the corresponding elements in the\norder they appeared in <code>coll</code>.</p>\n","related":["cljs.core/partition-by","cljs.core/frequencies"]},"cljs.core/hash-map":{"full-name":"cljs.core/hash-map","signature":["[& keyvals]"],"description-html":"<p>Returns a new hash map with supplied mappings.</p>\n<p><code>keyvals</code> must be an even number of forms.</p>\n","related":["cljs.core/array-map","cljs.core/sorted-map"]},"cljs.core/hash-set":{"full-name":"cljs.core/hash-set","signature":["[]","[& keys]"],"description-html":"<p>Returns a new hash set with supplied <code>keys</code>.</p>\n<p>Any equal keys are handled as if by repeated uses of <code>conj</code>.</p>\n","related":["cljs.core/set","cljs.core/sorted-set"]},"cljs.core/identical?":{"full-name":"cljs.core/identical?","signature":["[x y]"],"description-html":"<p>Returns true if <code>x</code> and <code>y</code> are the same object, false otherwise.</p>\n","related":["cljs.core/=","cljs.core/=="]},"cljs.core/identity":{"full-name":"cljs.core/identity","signature":["[x]"],"description-html":"<p>Returns its argument.</p>\n","related":["cljs.core/nil?"]},"cljs.core/if":{"full-name":"cljs.core/if","signature":["[test then else?]"],"description-html":"<p>If <code>test</code> is not false or nil, <code>then</code> is evaluated and returned. Otherwise,\n<code>else?</code> is evaluated and returned. <code>else?</code> defaults to nil if not provided.</p>\n<p><code>if</code> is one of ClojureScript&#39;s <a href=\"http://clojure.org/special_forms\">special forms</a>\nand is a fundamental building block of the language. All other conditionals in\nClojureScript are based on <code>if</code>s notion of truthiness (ie: anything other than\nfalse or nil).</p>\n","related":["cljs.core/cond","cljs.core/when","cljs.core/if-let","cljs.core/if-not"],"type":"special form"},"cljs.core/if-let":{"full-name":"cljs.core/if-let","signature":["[[x test] then]","[[x test] then else]"],"description-html":"<p>When <code>test</code> is logical true, evaluates <code>then</code> with the value of <code>test</code> bound to\n<code>x</code>. Otherwise, evaluates <code>else</code> with no bindings.</p>\n<p><code>else</code> defaults to nil.</p>\n","related":["cljs.core/when-let","cljs.core/if"],"type":"macro"},"cljs.core/if-not":{"full-name":"cljs.core/if-not","signature":["[test then]","[test then else]"],"description-html":"<p>If <code>test</code> is false or nil, evaluates and returns <code>then</code>. Otherwise, evaluates\nand returns <code>else</code>. <code>else</code> defaults to nil if not provided.</p>\n","related":["cljs.core/if","cljs.core/when-not"],"type":"macro"},"cljs.core/if-some":{"full-name":"cljs.core/if-some","signature":["[[x test] then]","[[x test] then else]"],"description-html":"<p>If <code>test</code> is not nil, evaluates <code>then</code> with <code>x</code> bound to the value of <code>test</code>. If\nnot, yields <code>else</code>.</p>\n","related":["cljs.core/when-some"],"type":"macro"},"cljs.core/ifn?":{"full-name":"cljs.core/ifn?","signature":["[f]"],"description-html":"<p>Returns true if <code>f</code> implements the <code>IFn</code> protocol, false otherwise.</p>\n<p>Functions, keywords, map, sets, and vectors can be called as functions.</p>\n","related":["cljs.core/fn?"]},"cljs.core/inc":{"full-name":"cljs.core/inc","signature":["[x]"],"description-html":"<p>Returns a number one greater than <code>x</code>.</p>\n","related":["cljs.core/dec"]},"cljs.core/instance?":{"full-name":"cljs.core/instance?","signature":["[t o]"],"description-html":"<p>Returns true if <code>o</code> is an instance of type <code>t</code>, false otherwise.</p>\n","related":["cljs.core/type"]},"cljs.core/int":{"full-name":"cljs.core/int","signature":["[x]"],"description-html":"<p>Coerces <code>x</code> to an integer by stripping decimal places.</p>\n","related":["cljs.core/char","cljs.core/integer?"]},"cljs.core/integer?":{"full-name":"cljs.core/integer?","signature":["[n]"],"description-html":"<p>Returns true if <code>n</code> is an integer, false otherwise.</p>\n","related":["cljs.core/int"]},"cljs.core/interleave":{"full-name":"cljs.core/interleave","signature":["[c1 c2]","[c1 c2 & colls]"],"description-html":"<p>Returns a lazy seq of the first item in each collection, then the second items,\nthen the third, etc.</p>\n","related":["cljs.core/interpose","cljs.core/zipmap"]},"cljs.core/interpose":{"full-name":"cljs.core/interpose","signature":["[sep coll]"],"description-html":"<p>Returns a lazy seq of the elements of <code>coll</code> separated by <code>sep</code>.</p>\n","related":["cljs.core/interleave","clojure.string/join"]},"cljs.core/into":{"full-name":"cljs.core/into","signature":["[to from]","[to xform from]"],"description-html":"<p>Returns a new collection consisting of <code>to</code> with all of the items of <code>from</code>\n&quot;added&quot; using <code>conj</code>.</p>\n<p>A transducer may be supplied as <code>xform</code>.</p>\n","related":["cljs.core/conj"]},"cljs.core/into-array":{"full-name":"cljs.core/into-array","signature":["[aseq]"],"description-html":"<p>Returns a new JavaScript array from the elements of <code>aseq</code>.</p>\n","related":["cljs.core/to-array","cljs.core/make-array"]},"cljs.core/iterate":{"full-name":"cljs.core/iterate","signature":["[f x]"],"description-html":"<p>Returns a lazy sequence of <code>x</code>, <code>(f x)</code>, <code>(f (f x))</code> etc.</p>\n<p><code>f</code> must be free of side-effects.</p>\n","related":["cljs.core/cycle","cljs.core/repeatedly","cljs.core/repeat"]},"cljs.core/js->clj":{"full-name":"cljs.core/js->clj","signature":["[x]","[x & opts]"],"description-html":"<p>Recursively transforms JavaScript arrays into ClojureScript vectors, and\nJavaScript objects into ClojureScript maps.</p>\n<p>Pass options <code>:keywordize-keys true</code> to recursively convert object property\nnames from strings to keywords.</p>\n<p><code>(js-&gt;clj js-data :keywordize-keys true)</code></p>\n<p>Note that <code>js-&gt;clj</code> is not optimized for speed and the <a href=\"http://swannodette.github.io/2014/07/26/transit-clojurescript\">transit.cljs</a> library is\nrecommended when parsing large amounts of JSON data.</p>\n","related":["cljs.core/clj->js"]},"cljs.core/js-delete":{"full-name":"cljs.core/js-delete","signature":["[obj key]"],"description-html":"<p>Deletes property <code>key</code> in JavaScript object <code>obj</code>.</p>\n<p>Uses the JavaScript <code>delete</code> operator.</p>\n","related":["cljs.core/dissoc"]},"cljs.core/js-keys":{"full-name":"cljs.core/js-keys","signature":["[obj]"],"description-html":"<p>Lists properties of JavaScript object <code>obj</code>.</p>\n","related":["cljs.core/keys"]},"cljs.core/js-obj":{"full-name":"cljs.core/js-obj","signature":["[& keyvals]"],"description-html":"<p>Returns a new JavaScript object using the supplied mappings.</p>\n<p><code>keyvals</code> must be an even number of forms.</p>\n","related":["cljs.core/array"]},"cljs.core/juxt":{"full-name":"cljs.core/juxt","signature":["[f]","[f g]","[f g h]","[f g h & fs]"],"description-html":"<p>Takes a set of functions and returns a function that is the juxtaposition of\nthose functions.</p>\n<p>The returned function takes a variable number of arguments, and returns a vector\ncontaining the result of applying each function to the arguments (left-to-\nright).</p>\n<p><code>((juxt a b c) x)</code> =&gt; <code>[(a x) (b x) (c x)]</code></p>\n","related":["cljs.core/partial","cljs.core/comp"]},"cljs.core/keep":{"full-name":"cljs.core/keep","signature":["[f]","[f coll]"],"description-html":"<p>Returns a lazy sequence of the non-nil results of <code>(f item)</code>. Note, this means\nfalse return values will be included.</p>\n<p><code>f</code> must be free of side-effects.</p>\n<p>Returns a transducer when no collection is provided.</p>\n","related":["cljs.core/keep-indexed","cljs.core/map","cljs.core/filter"]},"cljs.core/keep-indexed":{"full-name":"cljs.core/keep-indexed","signature":["[f]","[f coll]"],"description-html":"<p>Returns a lazy sequence of the non-nil results of <code>(f index item)</code>. Note, this\nmeans false return values will be included.</p>\n<p>`f must be free of side-effects.</p>\n<p>Returns a stateful transducer when no collection is provided.</p>\n","related":["cljs.core/map-indexed","cljs.core/keep"]},"cljs.core/key":{"full-name":"cljs.core/key","signature":["[map-entry]"],"description-html":"<p>Returns the key of the map entry.</p>\n","related":["cljs.core/keys"]},"cljs.core/keys":{"full-name":"cljs.core/keys","signature":["[hash-map]"],"description-html":"<p>Returns a sequence of the keys in <code>hash-map</code>.</p>\n","related":["cljs.core/vals"]},"cljs.core/last":{"full-name":"cljs.core/last","signature":["[coll]"],"description-html":"<p>Returns the last item in <code>coll</code> in linear time.</p>\n<p><code>peek</code> is much faster than <code>last</code> for a vector.</p>\n","related":["cljs.core/first","cljs.core/next","cljs.core/rest","cljs.core/butlast","cljs.core/take-last"]},"cljs.core/lazy-cat":{"full-name":"cljs.core/lazy-cat","signature":["[& colls]"],"description-html":"<p>Expands to code which yields a lazy sequence of the concatenation of the\nsupplied collections. Each collections expression is not evaluated until it is\nneeded.</p>\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><code>(lazy-cat x y z)</code>\n      <td><pre>\n(concat (lazy-seq x)\n        (lazy-seq y)\n        (lazy-seq z))</pre></td></tr></tbody></table>","related":["cljs.core/lazy-seq","cljs.core/concat"],"type":"macro"},"cljs.core/lazy-seq":{"full-name":"cljs.core/lazy-seq","signature":["[& body]"],"description-html":"<p>Returns a new lazy sequence.</p>\n","related":["cljs.core/lazy-cat","cljs.core/realized?","cljs.core/doall","cljs.core/iterate"]},"cljs.core/let":{"full-name":"cljs.core/let","signature":["[bindings & body]"],"description-html":"<p>Binds expressions to symbols and makes those symbols available only within\n<code>body</code>.</p>\n<p><code>bindings</code> should be a vector with an even number of forms, ie: <code>[a1 b1, a2 b2,\na3 b3]</code>. The first item in a pair (the <code>a</code>s) should be a symbol that is assigned\nthe evaluation of the second item (the <code>b</code>s). These symbols (the <code>a</code>s) are then\navailable within <code>body</code> (and not outside of <code>body</code>).</p>\n<p>Another way to think about this is that the binding symbols in <code>let</code> are like\nlocal <code>def</code>s that are only available within <code>let</code>&#39;s scope.</p>\n<p>In addition to direct symbol binding, <code>let</code> supports a destructuring syntax to\n&quot;break apart&quot; collections into multiple symbols. This destructuring syntax is\nlike it&#39;s own <a href=\"http://blog.jayfields.com/2010/07/clojure-destructuring.html\">mini-language</a> and allows for succinct code.</p>\n<p><code>let</code> is one of ClojureScript&#39;s <a href=\"http://clojure.org/special_forms\">special forms</a> and is a fundamental building\nblock of the language. Many macros rely on <code>let</code>s binding syntax and scope\nrules.</p>\n","related":["cljs.core/letfn","cljs.core/if-let"],"type":"special form"},"cljs.core/letfn":{"full-name":"cljs.core/letfn","signature":["[fnspecs & body]"],"description-html":"<p>Takes a vector of function definitions <code>fnspecs</code> and binds the functions to\ntheir names. All of the names are available in all of the definitions of the\nfunctions as well as <code>body</code>.</p>\n<p><code>fnspecs</code> must be a vector with an even number of forms. See <code>let</code>.</p>\n<p><code>letfn</code> is one of ClojureScript&#39;s <a href=\"http://clojure.org/special_forms\">special forms</a>.</p>\n","related":["cljs.core/let"],"type":"special form"},"cljs.core/list":{"full-name":"cljs.core/list","signature":["[& items]"],"description-html":"<p>Creates a new list containing <code>items</code>.</p>\n","related":["cljs.core/vector","cljs.core/list?"]},"cljs.core/list*":{"full-name":"cljs.core/list*","signature":["[args]","[a args]","[a b args]","[a b c args]","[a b c d & more]"],"description-html":"<p>Creates a new list containing the items prepended to the rest, the last of which\nwill be treated as a sequence.</p>\n","related":["cljs.core/list"]},"cljs.core/list?":{"full-name":"cljs.core/list?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a list, false otherwise.</p>\n","related":["cljs.core/seq?","cljs.core/sequential?","cljs.core/coll?"]},"cljs.core/make-array":{"full-name":"cljs.core/make-array","signature":["[size]"],"description-html":"<p>Creates an empty JavaScript array of size <code>size</code>.</p>\n","related":["cljs.core/aclone","cljs.core/array"]},"cljs.core/map":{"full-name":"cljs.core/map","signature":["[f]","[f coll]","[f c1 c2]","[f c1 c2 c3]","[f c1 c2 c3 & colls]"],"description-html":"<p>Returns a lazy sequence of applying function <code>f</code> to every element of <code>coll</code>.</p>\n<p>When more than one collection is provided, returns a lazy sequence consisting of\nthe result of applying <code>f</code> to the set of first items of each <code>c</code>, followed by\napplying <code>f</code> to the set of second items in each <code>c</code>, until any one of the <code>c</code>s\nis exhausted. Any remaining items in other <code>c</code>s are ignored. Function <code>f</code> should\naccept number-of-<code>c</code>s arguments.</p>\n<p>Returns a transducer when no collection is provided.</p>\n","related":["cljs.core/map-indexed","cljs.core/pmap","cljs.core/amap","cljs.core/mapcat","cljs.core/keep","cljs.core/juxt"]},"cljs.core/map-indexed":{"full-name":"cljs.core/map-indexed","signature":["[f coll]"],"description-html":"<p>Returns a lazy sequence consisting of the result of applying <code>f</code> to 0 and the\nfirst item of <code>coll</code>, followed by applying <code>f</code> to 1 and the second item in\n<code>coll</code>, etc, until <code>coll</code> is exhausted.</p>\n<p>Function <code>f</code> should accept 2 arguments, index and item.</p>\n","related":["cljs.core/map","cljs.core/keep-indexed"]},"cljs.core/map?":{"full-name":"cljs.core/map?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a map, false otherwise.</p>\n","related":["cljs.core/hash-map","cljs.core/sorted-map"]},"cljs.core/mapcat":{"full-name":"cljs.core/mapcat","signature":["[f]","[f & colls]"],"description-html":"<p>Returns the result of applying <code>concat</code> to the result of applying <code>map</code> to <code>f</code>\nand <code>colls</code>.</p>\n<p>Function <code>f</code> should return a collection.</p>\n<p>Returns a transducer when no collections are provided.</p>\n","related":["cljs.core/map","cljs.core/concat"]},"cljs.core/mapv":{"full-name":"cljs.core/mapv","signature":["[f coll]","[f c1 c2]","[f c1 c2 c3]","[f c1 c2 c3 & colls]"],"description-html":"<p>Returns a vector consisting of the result of applying <code>f</code> to the set of first\nitems of each coll, followed by applying <code>f</code> to the set of second items in each\ncoll, until any one of the colls is exhausted. Any remaining items in other\ncolls are ignored.</p>\n<p>Function <code>f</code> should accept number-of-colls arguments.</p>\n","related":["cljs.core/map"]},"cljs.core/max":{"full-name":"cljs.core/max","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns the greatest number argument.</p>\n","related":["cljs.core/min","cljs.core/max-key"]},"cljs.core/max-key":{"full-name":"cljs.core/max-key","signature":["[k x]","[k x y]","[k x y & more]"],"description-html":"<p>Returns the <code>x</code> for which <code>(k x)</code> is greatest.</p>\n<p><code>(k x)</code> should return a number.</p>\n","related":["cljs.core/max","cljs.core/min-key"]},"cljs.core/memoize":{"full-name":"cljs.core/memoize","signature":["[f]"],"description-html":"<p>Returns a memoized version of a referentially transparent function.</p>\n<p>A memoized version of a function keeps a cache of the mappings from arguments to\nresults in memory. When calls with the same arguments are repeated often, a\nmemoized function has higher performance at the expense of higher memory usage.</p>\n"},"cljs.core/merge":{"full-name":"cljs.core/merge","signature":["[& maps]"],"description-html":"<p>Returns a map that consists of the rest of the maps <code>conj</code>-ed onto the first.</p>\n<p>If a key occurs in more than one map, the mapping from the rightmost map will\n&quot;win&quot;.</p>\n","related":["cljs.core/merge-with","cljs.core/hash-map"]},"cljs.core/merge-with":{"full-name":"cljs.core/merge-with","signature":["[f & maps]"],"description-html":"<p>Returns a map that consists of the rest of the maps <code>conj</code>-ed onto the first.</p>\n<p>If a key occurs in more than one map, the mapping(s) from the latter (left-to-\nright) will be combined with the mapping in the result by calling <code>(f val-in-\nresult val-in-latter)</code>.</p>\n","related":["cljs.core/merge"]},"cljs.core/min":{"full-name":"cljs.core/min","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns the least number argument.</p>\n","related":["cljs.core/max","cljs.core/min-key"]},"cljs.core/min-key":{"full-name":"cljs.core/min-key","signature":["[k x]","[k x y]","[k x y & more]"],"description-html":"<p>Returns the <code>x</code> for which <code>(k x)</code> is least.</p>\n<p><code>(k x)</code> should return a number.</p>\n","related":["cljs.core/min","cljs.core/max-key"]},"cljs.core/mod":{"full-name":"cljs.core/mod","signature":["[n d]"],"description-html":"<p>Returns the modulus of dividing numerator <code>n</code> by denominator <code>d</code>.</p>\n<p>Returns <code>NaN</code> when <code>d</code> is 0 (divide by 0 error).</p>\n<p>Truncates toward negative infinity.</p>\n","related":["cljs.core/rem"]},"cljs.core/name":{"full-name":"cljs.core/name","signature":["[x]"],"description-html":"<p>Returns a string value of a keyword, string, or symbol.</p>\n<p><code>(name :foo)</code> =&gt; <code>&quot;foo&quot;</code></p>\n<p><code>(name &quot;foo&quot;)</code> =&gt; <code>&quot;foo&quot;</code></p>\n<p><code>(name &#39;foo)</code> =&gt; <code>&quot;foo&quot;</code></p>\n"},"cljs.core/neg?":{"full-name":"cljs.core/neg?","signature":["[n]"],"description-html":"<p>Returns true if <code>n</code> is less than 0, false otherwise.</p>\n","related":["cljs.core/pos?","cljs.core/zero?"]},"cljs.core/next":{"full-name":"cljs.core/next","signature":["[coll]"],"description-html":"<p>Returns a sequence of the items after the first and calls <code>seq</code> on its argument.</p>\n<p>Returns nil if <code>coll</code> is empty.</p>\n","related":["cljs.core/rest","cljs.core/first","cljs.core/fnext"]},"cljs.core/nfirst":{"full-name":"cljs.core/nfirst","signature":["[coll]"],"description-html":"<p>Same as <code>(next (first coll))</code>.</p>\n","related":["cljs.core/next"]},"cljs.core/nil?":{"full-name":"cljs.core/nil?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is nil, false otherwise.</p>\n","related":["cljs.core/true?","cljs.core/false?","cljs.core/identity"]},"cljs.core/nnext":{"full-name":"cljs.core/nnext","signature":["[coll]"],"description-html":"<p>Same as <code>(next (next coll))</code>.</p>\n","related":["cljs.core/next"]},"cljs.core/not":{"full-name":"cljs.core/not","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is logical false, false otherwise.</p>\n","related":["cljs.core/complement","cljs.core/false?"]},"cljs.core/not-any?":{"full-name":"cljs.core/not-any?","signature":["[pred coll]"],"description-html":"<p>Returns false if <code>(pred x)</code> is logical true for any <code>x</code> in <code>coll</code>, else true.</p>\n","related":["cljs.core/every?","cljs.core/some"]},"cljs.core/not-empty":{"full-name":"cljs.core/not-empty","signature":["[coll]"],"description-html":"<p>Returns nil if <code>coll</code> is empty, else returns <code>coll</code>.</p>\n","related":["cljs.core/empty"]},"cljs.core/not-every?":{"full-name":"cljs.core/not-every?","signature":["[pred coll]"],"description-html":"<p>Returns false if <code>(pred x)</code> is logical true for every <code>x</code> in <code>coll</code>, else true.</p>\n","related":["cljs.core/every?","cljs.core/not-any?","cljs.core/some"]},"cljs.core/not=":{"full-name":"cljs.core/not=","signature":["[x]","[x y]","[x y & more]"],"description-html":"<p>Returns the opposite of <code>=</code>.</p>\n<p>Same as <code>(not (= x y))</code></p>\n","related":["cljs.core/=","cljs.core/not"]},"cljs.core/ns":{"full-name":"cljs.core/ns","signature":["[name & references]"],"description-html":"<p>Sets the namespace of the file.</p>\n<p><code>ns</code> must be the first form in a <code>.cljs</code> file and there can only be one <code>ns</code>\ndeclaration per file. Namespaces must match the file name of their respective\n<code>.cljs</code> files, with the exception that dashes in namespaces become underscores\nin filenames. Thus, <code>(ns foo.bar-biz.baz)</code> should be the first form in file\n<code>foo/bar_biz/baz.cljs</code>.</p>\n<p><code>references</code> can be zero or more forms used to import other namespaces, symbols,\nand libraries into the current namespace.</p>\n","type":"special form"},"cljs.core/nth":{"full-name":"cljs.core/nth","signature":["[coll n]","[coll n not-found]"],"description-html":"<p>Returns the value at index <code>n</code> or <code>not-found</code> if the index is out of bounds.</p>\n<p><code>nth</code> will throw an exception if <code>n</code> is out of bounds and <code>not-found</code> is not\nsupplied.</p>\n<p><code>nth</code> works for Strings, Arrays, Regex Matchers, Lists, and Sequences. For\nSequences, <code>nth</code> takes O(n) time.</p>\n","related":["cljs.core/first","cljs.core/second","cljs.core/nthnext","cljs.core/get"]},"cljs.core/nthnext":{"full-name":"cljs.core/nthnext","signature":["[coll n]"],"description-html":"<p>Returns the <code>n</code>th <code>next</code> of <code>coll</code>.</p>\n<p>Returns <code>(seq coll)</code> when <code>n</code> is 0.</p>\n","related":["cljs.core/nth","cljs.core/drop","cljs.core/nthrest"]},"cljs.core/nthrest":{"full-name":"cljs.core/nthrest","signature":["[coll n]"],"description-html":"<p>Returns the <code>nth</code> rest of <code>coll</code>.</p>\n<p>Returns <code>coll</code> when <code>n</code> is 0.</p>\n","related":["cljs.core/drop","cljs.core/nthnext","cljs.core/nth"]},"cljs.core/number?":{"full-name":"cljs.core/number?","signature":["[n]"],"description-html":"<p>Returns true if <code>n</code> is a number, false otherwise.</p>\n","related":["cljs.core/integer?"]},"cljs.core/object?":{"full-name":"cljs.core/object?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a JavaScript object, false otherwise.</p>\n","related":["cljs.core/array?"]},"cljs.core/odd?":{"full-name":"cljs.core/odd?","signature":["[n]"],"description-html":"<p>Returns true if <code>n</code> is an odd number.</p>\n<p>Throws an exception if <code>n</code> is not an integer.</p>\n","related":["cljs.core/even?"]},"cljs.core/or":{"full-name":"cljs.core/or","signature":["[]","[x]","[x & next]"],"description-html":"<p>Evaluates arguments one at a time from left to right. If an argument returns\nlogical true, <code>or</code> returns that value and doesn&#39;t evaluate any of the other\narguments, otherwise it returns the value of the last argument.</p>\n<p><code>(or)</code> returns nil.</p>\n","related":["cljs.core/and","cljs.core/if"],"type":"macro"},"cljs.core/partial":{"full-name":"cljs.core/partial","signature":["[f]","[f arg1]","[f arg1 arg2]","[f arg1 arg2 arg3]","[f arg1 arg2 arg3 & more]"],"description-html":"<p>Takes a function <code>f</code> and fewer than the normal arguments to <code>f</code>. Returns a\nfunction that takes a variable number of additional arguments. When called, the\nreturned function calls <code>f</code> with the original arguments plus the additional\narguments.</p>\n<p><code>((partial f a b) c d)</code> =&gt; <code>(f a b c d)</code></p>\n","related":["cljs.core/comp","cljs.core/juxt"]},"cljs.core/partition":{"full-name":"cljs.core/partition","signature":["[n coll]","[n step coll]","[n step pad coll]"],"description-html":"<p>Returns a lazy sequence of lists of <code>n</code> items each, at offsets <code>step</code> apart.</p>\n<p>If <code>step</code> is not supplied, defaults to <code>n</code>, i.e. the partitions do not overlap.</p>\n<p>If a <code>pad</code> collection is supplied, its elements will be used as necessary to\ncomplete the last partition up to <code>n</code> items.</p>\n<p>Returns a partition with less than <code>n</code> items if there are not enough padding\nelements.</p>\n","related":["cljs.core/partition-all","cljs.core/split-at","cljs.core/partition-by"]},"cljs.core/partition-all":{"full-name":"cljs.core/partition-all","signature":["[n]","[n coll]","[n step coll]"],"description-html":"<p>Returns a lazy sequence of lists like <code>partition</code>, but may include partitions\nwith fewer than <code>n</code> items at the end.</p>\n<p>Returns a stateful transducer when no collection is provided.</p>\n","related":["cljs.core/partition","cljs.core/partition-by"]},"cljs.core/partition-by":{"full-name":"cljs.core/partition-by","signature":["[f]","[f coll]"],"description-html":"<p>Applies <code>f</code> to each value in <code>coll</code>, splitting it each time <code>f</code> returns a new\nvalue. Returns a lazy sequence of partitions.</p>\n<p>Returns a stateful transducer when no collection is provided.</p>\n","related":["cljs.core/partition","cljs.core/partition-all","cljs.core/group-by"]},"cljs.core/peek":{"full-name":"cljs.core/peek","signature":["[coll]"],"description-html":"<p>Returns the first element of a list; same as <code>first</code>.</p>\n<p>Returns the last element of a vector, and much more efficient than using <code>last</code>.</p>\n<p>Returns nil if <code>coll</code> is empty.</p>\n","related":["cljs.core/first","cljs.core/pop","cljs.core/conj"]},"cljs.core/pop":{"full-name":"cljs.core/pop","signature":["[coll]"],"description-html":"<p>For a list, returns a new list without the first item.</p>\n<p>For a vector, returns a new vector without the last item.</p>\n","related":["cljs.core/peek","cljs.core/rest","cljs.core/conj"]},"cljs.core/pos?":{"full-name":"cljs.core/pos?","signature":["[n]"],"description-html":"<p>Returns true if <code>n</code> is greater than 0, false otherwise.</p>\n","related":["cljs.core/neg?","cljs.core/zero?"]},"cljs.core/quot":{"full-name":"cljs.core/quot","signature":["[n d]"],"description-html":"<p>Returns the quotient of dividing numerator <code>n</code> by denominator <code>d</code>.</p>\n<p>Returns <code>NaN</code> when <code>d</code> is 0 (divide by 0 error).</p>\n","related":["cljs.core/rem","cljs.core/mod"]},"cljs.core/rand":{"full-name":"cljs.core/rand","signature":["[]","[n]"],"description-html":"<p>Returns a random floating point number between 0 inclusive and <code>n</code> exclusive.</p>\n<p><code>n</code> defaults to 1.</p>\n","related":["cljs.core/rand-int","cljs.core/rand-nth"]},"cljs.core/rand-int":{"full-name":"cljs.core/rand-int","signature":["[n]"],"description-html":"<p>Returns a random integer between 0 inclusive and <code>n</code> exclusive.</p>\n","related":["cljs.core/rand"]},"cljs.core/rand-nth":{"full-name":"cljs.core/rand-nth","signature":["[coll]"],"description-html":"<p>Returns a random element from a sequential collection <code>coll</code>.</p>\n<p>Has the same performance characteristics as <code>nth</code>.</p>\n","related":["cljs.core/rand"]},"cljs.core/range":{"full-name":"cljs.core/range","signature":["[]","[end]","[start end]","[start end step]"],"description-html":"<p>Returns a lazy sequence of nums from <code>start</code> (inclusive) to <code>end</code> (exclusive),\nby <code>step</code>, where <code>start</code> defaults to 0, <code>step</code> to 1, and <code>end</code> to infinity.</p>\n","related":["cljs.core/repeat"]},"cljs.core/re-find":{"full-name":"cljs.core/re-find","signature":["[re s]"],"description-html":"<p>Returns the first regex match, if any, of <code>s</code> to <code>re</code>, using <code>re.exec(s)</code>.</p>\n<p>Returns a vector, containing first the matching substring, then any capturing\ngroups if the regular expression contains capturing groups.</p>\n"},"cljs.core/re-matches":{"full-name":"cljs.core/re-matches","signature":["[re s]"],"description-html":"<p>Returns the result of <code>(re-find re s)</code> if <code>re</code> fully matches <code>s</code>.</p>\n"},"cljs.core/re-pattern":{"full-name":"cljs.core/re-pattern","signature":["[s]"],"description-html":"<p>Returns an instance of RegExp which has compiled the provided string.</p>\n"},"cljs.core/re-seq":{"full-name":"cljs.core/re-seq","signature":["[re s]"],"description-html":"<p>Returns a lazy sequence of successive matches of regex <code>re</code> in string <code>s</code>.</p>\n","related":["cljs.core/re-find","cljs.core/re-groups","cljs.core/re-pattern","cljs.core/re-matcher","cljs.core/re-matches","cljs.core/subs","clojure.string/split"]},"cljs.core/realized?":{"full-name":"cljs.core/realized?","signature":["[x]"],"description-html":"<p>Returns true if a value has been produced for a lazy sequence.</p>\n","related":["cljs.core/lazy-seq"]},"cljs.core/reduce":{"full-name":"cljs.core/reduce","signature":["[f coll]","[f val coll]"],"description-html":"<p><code>f</code> should be a function of 2 arguments. If <code>val</code> is not supplied, returns the\nresult of applying <code>f</code> to the first 2 items in <code>coll</code>, then applying <code>f</code> to that\nresult and the 3rd item, etc.</p>\n<p>If <code>coll</code> contains no items, <code>f</code> must accept no arguments as well, and <code>reduce</code>\nreturns the result of calling <code>f</code> with no arguments.</p>\n<p>If <code>coll</code> has only 1 item, it is returned and <code>f</code> is not called.</p>\n<p>If <code>val</code> is supplied, returns the result of applying <code>f</code> to <code>val</code> and the first\nitem in <code>coll</code>, then applying <code>f</code> to that result and the 2nd item, etc.</p>\n<p>If <code>coll</code> contains no items, returns <code>val</code> and <code>f</code> is not called.</p>\n","related":["cljs.core/reductions","cljs.core/apply","cljs.core/frequencies"]},"cljs.core/reduce-kv":{"full-name":"cljs.core/reduce-kv","signature":["[f init coll]"],"description-html":"<p>Reduces an associative collection.</p>\n<p><code>f</code> should be a function of 3 arguments. Returns the result of applying <code>f</code> to\n<code>init</code>, the first key and the first value in <code>coll</code>, then applying <code>f</code> to that\nresult and the 2nd key and value, etc.</p>\n<p>If <code>coll</code> contains no entries, returns <code>init</code> and <code>f</code> is not called.</p>\n<p>Note that <code>reduce-kv</code> is supported on vectors, where the keys will be the\nordinals.</p>\n","related":["cljs.core/reduce"]},"cljs.core/reductions":{"full-name":"cljs.core/reductions","signature":["[f coll]","[f init coll]"],"description-html":"<p>Returns a lazy sequence of the intermediate values of the reduction (as per\n<code>reduce</code>) of <code>coll</code> by <code>f</code>, starting with <code>init</code>.</p>\n","related":["cljs.core/reduce"]},"cljs.core/rem":{"full-name":"cljs.core/rem","signature":["[n d]"],"description-html":"<p>Returns the remainder of dividing numerator <code>n</code> by denominator <code>d</code>.</p>\n<p>Returns <code>NaN</code> when <code>d</code> is 0 (divide by 0 error).</p>\n","related":["cljs.core/quot","cljs.core/mod"]},"cljs.core/remove":{"full-name":"cljs.core/remove","signature":["[pred]","[pred coll]"],"description-html":"<p>Returns a lazy sequence of the items in <code>coll</code> for which <code>(pred item)</code> returns\nfalse.</p>\n<p><code>pred</code> must be free of side-effects.</p>\n<p>Returns a transducer when no collection is provided.</p>\n","related":["cljs.core/filter"]},"cljs.core/remove-watch":{"full-name":"cljs.core/remove-watch","signature":["[a key]"],"description-html":"<p>Removes a watch function identified by <code>key</code> from atom <code>a</code>.  The function must\nhave originally been set by <code>add-watch</code>.</p>\n","related":["cljs.core/add-watch"]},"cljs.core/repeat":{"full-name":"cljs.core/repeat","signature":["[x]","[n x]"],"description-html":"<p>Returns a lazy sequence of <code>x</code>s.</p>\n<p>The length of the sequence is infinite, or <code>n</code> if provided.</p>\n","related":["cljs.core/repeatedly","cljs.core/cycle","cljs.core/constantly","cljs.core/dotimes"]},"cljs.core/repeatedly":{"full-name":"cljs.core/repeatedly","signature":["[f]","[n f]"],"description-html":"<p>Takes a function <code>f</code> of no args, presumably with side effects, and returns an\ninfinite (or length <code>n</code> if supplied) lazy sequence of calls to it.</p>\n","related":["cljs.core/repeat","cljs.core/iterate","cljs.core/lazy-seq","cljs.core/dotimes","cljs.core/constantly"]},"cljs.core/replace":{"full-name":"cljs.core/replace","signature":["[smap]","[smap coll]"],"description-html":"<p>Given a map of replacement pairs <code>smap</code> and a vector/collection <code>coll</code>, returns\na vector/seq with any elements <code>=</code> to a key in <code>smap</code> replaced with the\ncorresponding val in <code>smap</code>.</p>\n<p>Returns a transducer when <code>coll</code> is not provided.</p>\n","related":["cljs.core/map","clojure.walk/prewalk-replace","clojure.walk/postwalk-replace"]},"cljs.core/reset!":{"full-name":"cljs.core/reset!","signature":["[a new-value]"],"description-html":"<p>Sets the value of atom <code>a</code> to <code>new-value</code> without regard for the current value.</p>\n<p>Returns <code>new-value</code>.</p>\n","related":["cljs.core/swap!","cljs.core/compare-and-set!","cljs.core/atom"]},"cljs.core/rest":{"full-name":"cljs.core/rest","signature":["[coll]"],"description-html":"<p>Returns a possibly empty sequence of the items after the first item.</p>\n<p>Calls <code>seq</code> on its argument.</p>\n","related":["cljs.core/next","cljs.core/first","cljs.core/drop","cljs.core/pop"]},"cljs.core/reverse":{"full-name":"cljs.core/reverse","signature":["[coll]"],"description-html":"<p>Returns a sequence of the items in <code>coll</code> in reverse order. Not lazy.</p>\n","related":["cljs.core/rseq"]},"cljs.core/reversible?":{"full-name":"cljs.core/reversible?","signature":["[coll]"],"description-html":"<p>Returns true if <code>coll</code> implements the <code>IReversible</code> protocol, false otherwise.</p>\n<p>Vectors, sorted maps, and sorted sets implement <code>IReversible</code>.</p>\n"},"cljs.core/rseq":{"full-name":"cljs.core/rseq","signature":["[coll]"],"description-html":"<p>Returns a sequence of the items in <code>coll</code> in reverse order in constant time.</p>\n<p>Returns nil if <code>coll</code> is empty.</p>\n<p><code>coll</code> must be a vector or a sorted-map.</p>\n","related":["cljs.core/reverse"]},"cljs.core/rsubseq":{"full-name":"cljs.core/rsubseq","signature":["[sc test key]","[sc start-test start-key end-test end-key]"],"description-html":"<p><code>sc</code> must be a sorted collection.</p>\n<p><code>test</code>, <code>start-test</code>, <code>end-test</code> must be <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> or <code>&gt;=</code>.</p>\n<p>Returns a reverse sequence of those entries with keys <code>ek</code> for which\n<code>(test (.. sc comparator (compare ek key)) 0)</code> is true.</p>\n","related":["cljs.core/subseq"]},"cljs.core/second":{"full-name":"cljs.core/second","signature":["[coll]"],"description-html":"<p>Returns the second item in <code>coll</code>.</p>\n<p>Same as <code>(first (next coll))</code></p>\n","related":["cljs.core/first","cljs.core/nth","cljs.core/fnext","cljs.core/next"]},"cljs.core/select-keys":{"full-name":"cljs.core/select-keys","signature":["[map keys]"],"description-html":"<p>Returns a map containing only those entries in <code>map</code> whose key is in <code>keys</code>.</p>\n"},"cljs.core/seq":{"full-name":"cljs.core/seq","signature":["[coll]"],"description-html":"<p>Returns a sequence on the collection. If the collection is empty, returns nil.</p>\n<p><code>(seq nil)</code> returns nil.</p>\n<p><code>seq</code> also works on strings.</p>\n","related":["cljs.core/seq?","cljs.core/empty?","cljs.core/iterator-seq"]},"cljs.core/seq?":{"full-name":"cljs.core/seq?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a sequence, false otherwise.</p>\n<p>All collections can be converted into a sequence using <code>seq</code>.</p>\n","related":["cljs.core/seq","cljs.core/sequential?","cljs.core/vector?","cljs.core/coll?","cljs.core/list?","cljs.core/map?","cljs.core/set?"]},"cljs.core/sequential?":{"full-name":"cljs.core/sequential?","signature":["[coll]"],"description-html":"<p>Returns true if <code>coll</code> implements the <code>ISequential</code> protocol, false otherwise.</p>\n<p>Lists and vectors are sequential.</p>\n","related":["cljs.core/seq?","cljs.core/coll?"]},"cljs.core/set":{"full-name":"cljs.core/set","signature":["[coll]"],"description-html":"<p>Returns a set of the distinct elements of <code>coll</code>.</p>\n","related":["cljs.core/hash-set","cljs.core/sorted-set","cljs.core/conj","cljs.core/disj","cljs.core/distinct","clojure.set/join","clojure.set/select","clojure.set/difference","clojure.set/intersection","clojure.set/union","clojure.set/index","clojure.set/project","clojure.set/rename","clojure.set/rename-keys","clojure.set/map-invert"]},"cljs.core/set!":{"full-name":"cljs.core/set!","signature":["[js-var val]"],"description-html":"<p>Sets <code>js-var</code> to <code>val</code> using the JavaScript <code>=</code> operator.</p>\n","related":["cljs.core/aset","cljs.core/reset!"]},"cljs.core/set-validator!":{"full-name":"cljs.core/set-validator!","signature":["[a fn]"],"description-html":"<p>Sets a validator function for atom <code>a</code>.</p>\n<p><code>fn</code> must be nil or a side-effect-free function of one argument, which will be\npassed the intended new state on any state change. <code>fn</code> should return false or\nthrow an Error if the new state is unacceptable.</p>\n<p>If the current value of <code>a</code> is unacceptable to <code>fn</code> when <code>set-validator!</code> is\ncalled, an Error will be thrown and the validator will not be set.</p>\n<p><code>(set-validator! my-atom nil)</code> will remove the validator from <code>my-atom</code>.</p>\n","related":["cljs.core/atom","cljs.core/get-validator"]},"cljs.core/set?":{"full-name":"cljs.core/set?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a set, false otherwise.</p>\n","related":["cljs.core/set"]},"cljs.core/shuffle":{"full-name":"cljs.core/shuffle","signature":["[coll]"],"description-html":"<p>Returns a random permutation of <code>coll</code>.</p>\n"},"cljs.core/some":{"full-name":"cljs.core/some","signature":["[pred coll]"],"description-html":"<p>Returns the first logical true value of <code>(pred x)</code> for any <code>x</code> in <code>coll</code>, else\nnil.</p>\n<p>A common idiom is to use a set as pred, for example this will return <code>:fred</code> if\n<code>:fred</code> is in the sequence, otherwise nil: <code>(some #{:fred} coll)</code></p>\n","related":["cljs.core/every?","cljs.core/not-any?","cljs.core/keep","cljs.core/keep-indexed","cljs.core/some-fn"]},"cljs.core/some->":{"full-name":"cljs.core/some->","signature":["[expr & forms]"],"description-html":"<p>When <code>expr</code> is not nil, threads it into the first form (via <code>-&gt;</code>), and when that\nresult is not nil, through the next, etc.</p>\n","related":["cljs.core/->","cljs.core/->>","cljs.core/some->>","cljs.core/some"],"type":"macro"},"cljs.core/some->>":{"full-name":"cljs.core/some->>","signature":["[expr & forms]"],"description-html":"<p>When <code>expr</code> is not nil, threads it into the first form (via <code>-&gt;&gt;</code>), and when\nthat result is not nil, through the next, etc.</p>\n","related":["cljs.core/->","cljs.core/->>","cljs.core/some->","cljs.core/some"],"type":"macro"},"cljs.core/some-fn":{"full-name":"cljs.core/some-fn","signature":["[p]","[p1 p2]","[p1 p2 p3]","[p1 p2 p3 & ps]"],"description-html":"<p>Takes a set of predicate functions and returns a function <code>f</code> that returns the\nfirst logical true value returned by one of its composing predicates against any\nof its arguments, else it returns logical false.</p>\n<p>Note that <code>f</code> is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates.</p>\n","related":["cljs.core/every-pred","cljs.core/some","cljs.core/or"]},"cljs.core/some?":{"full-name":"cljs.core/some?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is not nil, false otherwise.</p>\n","related":["cljs.core/true?","cljs.core/nil?"]},"cljs.core/sort":{"full-name":"cljs.core/sort","signature":["[coll]","[comp coll]"],"description-html":"<p>Returns a sorted sequence of the items in <code>coll</code>.</p>\n<p><code>comp</code> can be a boolean-valued comparison funcion, or a -/0/+ valued comparator.</p>\n<p><code>comp</code> defaults to <code>compare</code>.</p>\n","related":["cljs.core/sort-by"]},"cljs.core/sort-by":{"full-name":"cljs.core/sort-by","signature":["[keyfn coll]","[keyfn comp coll]"],"description-html":"<p>Returns a sorted sequence of the items in <code>coll</code>, where the sort order is\ndetermined by comparing <code>(keyfn item)</code>.</p>\n<p><code>comp</code> can be boolean-valued comparison function, or a -/0/+ valued comparator.</p>\n<p><code>comp</code> defaults to <code>compare</code>.</p>\n","related":["cljs.core/sort","cljs.core/compare"]},"cljs.core/sorted-map":{"full-name":"cljs.core/sorted-map","signature":["[& keyvals]"],"description-html":"<p>Returns a new sorted map with supplied mappings.</p>\n<p><code>keyvals</code> must be an even number of forms.</p>\n","related":["cljs.core/sorted-map-by","cljs.core/subseq","cljs.core/rsubseq","cljs.core/sorted-set","cljs.core/array-map","cljs.core/hash-map"]},"cljs.core/sorted-map-by":{"full-name":"cljs.core/sorted-map-by","signature":["[comparator & keyvals]"],"description-html":"<p>Returns a new sorted map with supplied mappings, using the supplied comparator\nfunction.</p>\n<p><code>keyvals</code> must be an even number of forms.</p>\n","related":["cljs.core/sorted-map","cljs.core/subseq","cljs.core/rsubseq","cljs.core/sorted-set-by"]},"cljs.core/sorted-set":{"full-name":"cljs.core/sorted-set","signature":["[& keys]"],"description-html":"<p>Returns a new sorted set with supplied <code>keys</code>.</p>\n","related":["cljs.core/sorted-set-by","cljs.core/subseq","cljs.core/rsubseq","cljs.core/sorted-map"]},"cljs.core/sorted-set-by":{"full-name":"cljs.core/sorted-set-by","signature":["[comparator & keys]"],"description-html":"<p>Returns a new sorted set with supplied <code>keys</code>, using the supplied <code>comparator</code>.</p>\n","related":["cljs.core/sorted-set","cljs.core/sorted-map-by","cljs.core/compare"]},"cljs.core/sorted?":{"full-name":"cljs.core/sorted?","signature":["[coll]"],"description-html":"<p>Returns true if <code>coll</code> implements the <code>ISorted</code> protocol, false otherwise.</p>\n<p>Sorted maps and sorted sets implement <code>ISorted</code>.</p>\n","related":["cljs.core/sorted-map","cljs.core/sorted-set"]},"cljs.core/split-at":{"full-name":"cljs.core/split-at","signature":["[n coll]"],"description-html":"<p>Returns a vector of <code>[(take n coll) (drop n coll)]</code>.</p>\n","related":["cljs.core/split-with","clojure.string/split"]},"cljs.core/split-with":{"full-name":"cljs.core/split-with","signature":["[pred coll]"],"description-html":"<p>Returns a vector of <code>[(take-while pred coll) (drop-while pred coll)]</code></p>\n","related":["cljs.core/split-at","clojure.string/split","cljs.core/take-while","cljs.core/drop-while"]},"cljs.core/str":{"full-name":"cljs.core/str","signature":["[]","[x]","[x & ys]"],"description-html":"<p><code>(str)</code> and <code>(str nil)</code> return the empty string.</p>\n<p><code>(str x)</code> returns <code>x.toString()</code>.</p>\n<p>With more than one argument, returns the concatenation of the <code>str</code> values of\nthe arguments.</p>\n"},"cljs.core/string?":{"full-name":"cljs.core/string?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a string, false otherwise.</p>\n"},"cljs.core/subs":{"full-name":"cljs.core/subs","signature":["[s start]","[s start end]"],"description-html":"<p>Returns the substring of <code>s</code> beginning at <code>start</code> inclusive, and ending at <code>end</code>\nexclusive.</p>\n<p><code>end</code> defaults to the length of the string.</p>\n"},"cljs.core/subseq":{"full-name":"cljs.core/subseq","signature":["[sc test key]","[sc start-test start-key end-test end-key]"],"description-html":"<p><code>sc</code> must be a sorted collection.</p>\n<p><code>test</code>, <code>start-test</code>, <code>end-test</code> must be <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> or <code>&gt;=</code>.</p>\n<p>Returns a sequence of those entries with keys <code>ek</code> for which\n<code>(test (.. sc comparator (compare ek key)) 0)</code> is true.</p>\n","related":["cljs.core/rsubseq","cljs.core/sorted-map","cljs.core/sorted-set","cljs.core/sorted-map-by","cljs.core/sorted-set-by"]},"cljs.core/subvec":{"full-name":"cljs.core/subvec","signature":["[v start]","[v start end]"],"description-html":"<p>Returns a persistent vector of the items in <code>v</code> from <code>start</code> inclusive to <code>end</code>\nexclusive.</p>\n<p>If <code>end</code> is not supplied, defaults to <code>(count v)</code>.</p>\n<p>This operation is O(1) and very fast, as the resulting vector shares structure\nwith the original and no trimming is done.</p>\n","related":["cljs.core/vector","cljs.core/vector?"]},"cljs.core/swap!":{"full-name":"cljs.core/swap!","signature":["[a f]","[a f x]","[a f x y]","[a f x y & more]"],"description-html":"<p>Atomically swaps the value of atom to be: <code>(apply f current-value-of-atom\nargs)</code></p>\n<p>Note that <code>f</code> may be called multiple times, and thus should be free of side\neffects.</p>\n<p>Returns the value that was swapped in.</p>\n","related":["cljs.core/atom","cljs.core/reset!"]},"cljs.core/take":{"full-name":"cljs.core/take","signature":["[n]","[n coll]"],"description-html":"<p>Returns a lazy sequence of the first <code>n</code> items in <code>coll</code>. Returns all the items\nif there are fewer than <code>n</code>.</p>\n<p>Returns a stateful transducer when no collection is provided.</p>\n","related":["cljs.core/drop","cljs.core/take-while","cljs.core/take-last","cljs.core/take-nth"]},"cljs.core/take-last":{"full-name":"cljs.core/take-last","signature":["[n coll]"],"description-html":"<p>Returns a sequence of the last <code>n</code> items in <code>coll</code>.</p>\n<p>Depending on the type of collection, <code>take-last</code> may be no faster than linear\ntime. For vectors, please use <code>subvec</code>.</p>\n","related":["cljs.core/last","cljs.core/butlast","cljs.core/drop-last"]},"cljs.core/take-nth":{"full-name":"cljs.core/take-nth","signature":["[n]","[n coll]"],"description-html":"<p>Returns a lazy seq of every <code>n</code>th item in <code>coll</code>.</p>\n<p>Returns a stateful transducer when no collection is provided.</p>\n"},"cljs.core/take-while":{"full-name":"cljs.core/take-while","signature":["[pred]","[pred coll]"],"description-html":"<p>Returns a lazy sequence of successive items from <code>coll</code> while <code>(pred item)</code>\nreturns true. <code>pred</code> must be free of side-effects.</p>\n<p>Returns a transducer when no collection is provided.</p>\n","related":["cljs.core/drop-while","cljs.core/split-with"]},"cljs.core/throw":{"full-name":"cljs.core/throw","signature":["[expr]"],"description-html":"<p><code>expr</code> is evaluated and thrown, hopefully to be caught by a <code>try</code> expression.</p>\n<p><code>(throw (js/Error. &quot;Oops!&quot;))</code></p>\n","related":["cljs.core/try","cljs.core/catch","cljs.core/finally"],"type":"special form"},"cljs.core/to-array-2d":{"full-name":"cljs.core/to-array-2d","signature":["[coll]"],"description-html":"<p>Returns a (potentially-ragged) 2-dimensional JavaScript array containing the\ncontents of <code>coll</code>.</p>\n","related":["cljs.core/to-array"]},"cljs.core/tree-seq":{"full-name":"cljs.core/tree-seq","signature":["[branch? children root]"],"description-html":"<p>Returns a lazy sequence of the nodes in a tree, via a depth-first walk.</p>\n<p><code>branch?</code> must be a function of one argument that returns true if passed a node\nthat can have children (but may not).</p>\n<p><code>children</code> must be a function of one argument that returns a sequence of the\nchildren. <code>children</code> will only be called on nodes for which <code>branch?</code> returns\ntrue.</p>\n<p><code>root</code> is the root node of the tree.</p>\n"},"cljs.core/true?":{"full-name":"cljs.core/true?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is the value true, false otherwise.</p>\n","related":["cljs.core/false?"]},"cljs.core/try":{"full-name":"cljs.core/try","signature":["[expr* catch-clause* finally-clause?]"],"description-html":"<p>The expressions (<code>expr*</code>) are evaluated and, if no exceptions occur, the value\nof the last is returned.</p>\n<p>If an exception occurs and catch clauses (<code>catch-clause*</code>) are provided, each is\nexamined in turn and the first for which the thrown exception is an instance of\nthe named class is considered a matching catch clause. If there is a matching\ncatch clause, its expressions are evaluated in a context in which name is bound\nto the thrown exception, and the value of the last is the return value of the\nfunction.</p>\n<p>If there is no matching catch clause, the exception propagates out of the\nfunction. Before returning, normally or abnormally, any <code>finally-clause?</code>\nexpressions will be evaluated for their side effects.</p>\n<p><code>try</code> is one of ClojureScript&#39;s <a href=\"http://clojure.org/special_forms\">special forms</a>.</p>\n","related":["cljs.core/catch","cljs.core/finally","cljs.core/throw"],"type":"special form"},"cljs.core/unsigned-bit-shift-right":{"full-name":"cljs.core/unsigned-bit-shift-right","signature":["[x n]"],"description-html":"<p>Bitwise shift right with zero fill</p>\n","related":["cljs.core/bit-shift-right"]},"cljs.core/update-in":{"full-name":"cljs.core/update-in","signature":["[m [k & ks] f]","[m [k & ks] f a]","[m [k & ks] f a b]","[m [k & ks] f a b c]","[m [k & ks] f a b c & args]"],"description-html":"<p>&quot;Updates&quot; a value in a nested associative structure, where <code>ks</code> is a sequence of\nkeys and <code>f</code> is a function that will take the old value and any supplied\narguments and return the new value. Returns a new nested structure.</p>\n<p>If any levels do not exist, hash-maps will be created.</p>\n","related":["cljs.core/assoc-in","cljs.core/get-in"]},"cljs.core/val":{"full-name":"cljs.core/val","signature":["[map-entry]"],"description-html":"<p>Returns the value in the map entry.</p>\n","related":["cljs.core/vals"]},"cljs.core/vals":{"full-name":"cljs.core/vals","signature":["[hash-map]"],"description-html":"<p>Returns a sequence of the values in <code>hash-map</code>.</p>\n","related":["cljs.core/keys"]},"cljs.core/vec":{"full-name":"cljs.core/vec","signature":["[coll]"],"description-html":"<p>Creates a new vector containing the contents of <code>coll</code></p>\n","related":["cljs.core/vector","cljs.core/vector?","cljs.core/vector-of"]},"cljs.core/vector":{"full-name":"cljs.core/vector","signature":["[& args]"],"description-html":"<p>Creates a new vector containing <code>args</code>.</p>\n","related":["cljs.core/vec","cljs.core/vector?","cljs.core/vector-of","cljs.core/pop","cljs.core/into"]},"cljs.core/vector?":{"full-name":"cljs.core/vector?","signature":["[x]"],"description-html":"<p>Returns true if <code>x</code> is a vector, false otherwise.</p>\n","related":["cljs.core/vector","cljs.core/vec"]},"cljs.core/when":{"full-name":"cljs.core/when","signature":["[test & body]"],"description-html":"<p>Evaluates <code>test</code>. If logical true, evaluates <code>body</code> in an implicit <code>do</code>.</p>\n<p><code>when</code> is often used instead of <code>if</code> for conditions that do not have an &quot;else&quot;.</p>\n","related":["cljs.core/when-not","cljs.core/when-let","cljs.core/if"],"type":"macro"},"cljs.core/when-first":{"full-name":"cljs.core/when-first","signature":["[bindings & body]"],"description-html":"<p>With <code>bindings</code> as <code>x</code>, <code>xs</code>, roughly the same as <code>(when (seq xs) (let [x (first\nxs)] body))</code> but <code>xs</code> is evaluated only once.</p>\n","type":"macro"},"cljs.core/when-let":{"full-name":"cljs.core/when-let","signature":["[[x test] & body]"],"description-html":"<p>When <code>test</code> is logical true, evaluates <code>body</code> with the value of <code>test</code> bound to\n<code>x</code>.</p>\n","related":["cljs.core/if-let","cljs.core/when","cljs.core/when-not","cljs.core/if","cljs.core/when-first"],"type":"macro"},"cljs.core/when-not":{"full-name":"cljs.core/when-not","signature":["[test & body]"],"description-html":"<p>Evaluates <code>test</code>. If logical false, evaluates <code>body</code> in an implicit <code>do</code>.</p>\n","related":["cljs.core/when","cljs.core/when-let","cljs.core/if"],"type":"macro"},"cljs.core/when-some":{"full-name":"cljs.core/when-some","signature":["[[x test] & body]"],"description-html":"<p>When <code>test</code> is not nil, evaluates <code>body</code> with <code>x</code> bound to the value of <code>test</code>.</p>\n","related":["cljs.core/if-some"],"type":"macro"},"cljs.core/while":{"full-name":"cljs.core/while","signature":["[test & body]"],"description-html":"<p>Repeatedly executes <code>body</code> while <code>test</code> expression is true. Presumes some\nside-effect will cause <code>test</code> to become false or nil.</p>\n<p>Returns nil.</p>\n","related":["cljs.core/loop"],"type":"macro"},"cljs.core/zero?":{"full-name":"cljs.core/zero?","signature":["[n]"],"description-html":"<p>Returns true if <code>n</code> is 0, false otherwise.</p>\n","related":["cljs.core/pos?","cljs.core/neg?"]},"cljs.core/zipmap":{"full-name":"cljs.core/zipmap","signature":["[keys vals]"],"description-html":"<p>Returns a map with <code>keys</code> mapped to corresponding <code>vals</code>.</p>\n<pre>user=> (zipmap [:a :b :c :d] [1 2 3 4])\n{:a 1, :b 2, :c 3, :d 4}</pre>","related":["cljs.core/interleave"]},"clojure.set/difference":{"full-name":"clojure.set/difference","signature":["[s1]","[s1 s2]","[s1 s2 & sets]"],"description-html":"<p>Return a set that is the first set without elements of the remaining sets.</p>\n","related":["clojure.set/union","clojure.set/intersection","clojure.set/superset?","clojure.set/project"]},"clojure.set/intersection":{"full-name":"clojure.set/intersection","signature":["[s1]","[s1 s2]","[s1 s2 & sets]"],"description-html":"<p>Return a set that is the intersection of the input sets.</p>\n","related":["clojure.set/union","clojure.set/difference","clojure.set/superset?","clojure.set/project"]},"clojure.set/select":{"full-name":"clojure.set/select","signature":["[pred xset]"],"description-html":"<p>Returns a set of the elements for which <code>pred</code> is true.</p>\n","related":["cljs.core/filter"]},"clojure.set/subset?":{"full-name":"clojure.set/subset?","signature":["[a b]"],"description-html":"<p>Returns true if <code>a</code> is a subset of <code>b</code>, false otherwise.</p>\n<p>In other words, returns true if all the elements of <code>a</code> can be found in <code>b</code>.</p>\n","related":["cljs.core/set","cljs.core/set?","clojure.set/superset?"]},"clojure.set/superset?":{"full-name":"clojure.set/superset?","signature":["[a b]"],"description-html":"<p>Returns true if <code>a</code> is a superset of <code>b</code>, false otherwise.</p>\n<p>In other words, returns true if <code>a</code> contains all the elements of <code>b</code>.</p>\n","related":["cljs.core/set","cljs.core/set?","clojure.set/subset?"]},"clojure.set/union":{"full-name":"clojure.set/union","signature":["[]","[s1]","[s1 s2]","[s1 s2 & sets]"],"description-html":"<p>Return a set that is the union of the input sets.</p>\n","related":["clojure.set/intersection","clojure.set/difference","clojure.set/superset?"]},"clojure.string/blank?":{"full-name":"clojure.string/blank?","signature":["[s]"],"description-html":"<p>True if <code>s</code> is nil, empty, or contains only whitespace.</p>\n"},"clojure.string/capitalize":{"full-name":"clojure.string/capitalize","signature":["[s]"],"description-html":"<p>Converts first character of the string to upper-case, all other characters to\nlower-case.</p>\n"},"clojure.string/escape":{"full-name":"clojure.string/escape","signature":["[s cmap]"],"description-html":"<p>Return a new string, using <code>cmap</code> to escape each character <code>ch</code> from <code>s</code> as follows:</p>\n<p>If <code>(cmap ch)</code> is nil, append ch to the new string.</p>\n<p>If <code>(cmap ch)</code> is non-nil, append <code>(str (cmap ch))</code> instead.</p>\n"},"clojure.string/join":{"full-name":"clojure.string/join","signature":["[coll]","[separator coll]"],"description-html":"<p>Returns a string of all elements in <code>coll</code>, as returned by <code>(seq coll)</code>,\nseparated by an optional separator.</p>\n"},"clojure.string/lower-case":{"full-name":"clojure.string/lower-case","signature":["[s]"],"description-html":"<p>Converts string to all lower-case.</p>\n"},"clojure.string/replace":{"full-name":"clojure.string/replace","signature":["[s match replacement]"],"description-html":"<p>Replaces all instance of <code>match</code> with <code>replacement</code> in <code>s</code>.</p>\n<p>The options for match / replacement are:</p>\n<table>\n<thead>\n<tr>\n<th>match</th>\n<th>replacement</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>string</td>\n<td>string</td>\n</tr>\n<tr>\n<td>regex</td>\n<td>string</td>\n</tr>\n<tr>\n<td>regex</td>\n<td>function</td>\n</tr>\n</tbody>\n</table>\n","related":["cljs.core/subs","clojure.string/split","clojure.string/replace-first"]},"clojure.string/replace-first":{"full-name":"clojure.string/replace-first","signature":["[s match replacement]"],"description-html":"<p>Replaces the first instance of <code>match</code> with <code>replacement</code> in <code>s</code>.</p>\n<p>The options for match / replacement are:</p>\n<table>\n<thead>\n<tr>\n<th>match</th>\n<th>replacement</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>string</td>\n<td>string</td>\n</tr>\n<tr>\n<td>regex</td>\n<td>string</td>\n</tr>\n<tr>\n<td>regex</td>\n<td>function</td>\n</tr>\n</tbody>\n</table>\n"},"clojure.string/reverse":{"full-name":"clojure.string/reverse","signature":["[s]"],"description-html":"<p>Returns <code>s</code> with its characters reversed.</p>\n"},"clojure.string/split":{"full-name":"clojure.string/split","signature":["[s re]","[s re limit]"],"description-html":"<p>Splits string on a regular expression. Optional argument limit is the maximum\nnumber of splits. Not lazy. Returns vector of the splits.</p>\n","related":["cljs.core/subs","clojure.string/replace","clojure.string/split-lines"]},"clojure.string/split-lines":{"full-name":"clojure.string/split-lines","signature":["[s]"],"description-html":"<p>Splits <code>s</code> on <code>\\n</code> or <code>\\r\\n</code>.</p>\n","related":["clojure.string/split"]},"clojure.string/trim":{"full-name":"clojure.string/trim","signature":["[s]"],"description-html":"<p>Removes whitespace from both ends of string.</p>\n"},"clojure.string/trim-newline":{"full-name":"clojure.string/trim-newline","signature":["[s]"],"description-html":"<p>Removes all trailing newline <code>\\n</code> or return <code>\\r</code> characters from string.</p>\n<p>Similar to Perl&#39;s chomp.</p>\n"},"clojure.string/triml":{"full-name":"clojure.string/triml","signature":["[s]"],"description-html":"<p>Removes whitespace from the left side of string.</p>\n"},"clojure.string/trimr":{"full-name":"clojure.string/trimr","signature":["[s]"],"description-html":"<p>Removes whitespace from the right side of string.</p>\n"},"clojure.string/upper-case":{"full-name":"clojure.string/upper-case","signature":["[s]"],"description-html":"<p>Converts string to all upper-case.</p>\n"}}